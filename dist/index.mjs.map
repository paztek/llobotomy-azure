{"version":3,"file":"index.mjs","sources":["../src/assistant/assistant.ts","../src/thread/thread.ts"],"sourcesContent":["import type {\n    ChatRequestMessage,\n    ChatRequestSystemMessage,\n    GetChatCompletionsOptions,\n    OpenAIClient,\n} from '@azure/openai';\nimport type { ChatCompletionsToolDefinition } from '@azure/openai/types/src/models/models';\nimport { Readable } from 'stream';\n\nexport interface AssistantCreateParams {\n    client: OpenAIClient;\n    instructions: string;\n    tools: ChatCompletionsToolDefinition[];\n    deployment: string;\n}\n\nexport class Assistant {\n    public readonly client: OpenAIClient;\n\n    private readonly instructions: string;\n    private readonly tools: ChatCompletionsToolDefinition[];\n    private readonly deployment: string;\n\n    constructor(params: AssistantCreateParams) {\n        this.client = params.client;\n        this.instructions = params.instructions;\n        this.tools = params.tools;\n        this.deployment = params.deployment;\n    }\n\n    listChatCompletions(messages: ChatRequestMessage[]): Readable {\n        // Prepend the messages with our instructions as a \"system\" message\n        const systemMessage: ChatRequestSystemMessage = {\n            role: 'system',\n            content: this.instructions,\n        };\n        messages = [systemMessage, ...messages];\n\n        const options: GetChatCompletionsOptions = {\n            tools: this.tools,\n        };\n\n        const completions = this.client.listChatCompletions(\n            this.deployment,\n            messages,\n            options,\n        );\n\n        return Readable.from(completions, {\n            objectMode: true,\n        });\n    }\n}\n","import type {\n    ChatCompletions,\n    ChatCompletionsToolCall,\n    ChatRequestMessage,\n    ChatRequestToolMessage,\n    ChatResponseMessage,\n} from '@azure/openai';\nimport EventEmitter from 'events';\nimport { Readable } from 'stream';\nimport { Assistant } from '../assistant';\n\nexport class Thread extends EventEmitter {\n    private readonly messages: (ChatRequestMessage | ChatResponseMessage)[] =\n        [];\n    private _stream: Readable | null = null;\n\n    constructor(messages: ChatRequestMessage[] = []) {\n        super();\n        this.messages = messages;\n    }\n\n    get stream(): Readable | null {\n        if (!this._stream) {\n            return null;\n        }\n\n        return this._stream;\n    }\n\n    addMessage(message: ChatRequestMessage): void {\n        this.doAddMessage(message);\n    }\n\n    run(assistant: Assistant): void {\n        this._stream = new Readable({\n            read: () => {},\n        });\n        this.doRun(assistant);\n    }\n\n    private doRun(assistant: Assistant): void {\n        this.emit('in_progress');\n\n        const messages = this.getRequestMessages();\n\n        const stream = assistant.listChatCompletions(messages);\n\n        /**\n         * When the LLM responds with some tool calls, the first completion's first choice usually looks like this:\n         * {\n         *   index: 0,\n         *   finishReason: null,\n         *   delta: {\n         *     role: 'assistant',\n         *     toolCalls: [\n         *         {\n         *             id: 'call_123abc',\n         *             type: 'function',\n         *             function: {\n         *                 name: 'get_customer_profile',\n         *                 arguments: ''\n         *             }\n         *         }\n         *     ]\n         *   },\n         *   contentFilterResults: {}\n         * }\n         *\n         * BUT it's not always the case. Sometimes the first toolCalls array is empty, content is also undefined.\n         * In that case, we need to wait for the next completion to determine if it's some tool calls or a chat message.\n         *\n         * When the LLM responds with a message, the first completion's first choice looks like this:\n         * {\n         *   index: 0,\n         *   finishReason: null,\n         *   delta: {\n         *     role: 'assistant',\n         *   },\n         *   contentFilterResults: {}\n         *\n         * We're only interested in the first completion and then we let the dedicated handler handle the rest of the stream\n         */\n\n        let content: string | null = null;\n        const toolCalls: ChatCompletionsToolCall[] = [];\n\n        stream.on('data', (completion: ChatCompletions) => {\n            const choice = completion.choices[0];\n            if (!choice) {\n                throw new Error('No completions returned');\n            }\n\n            const delta = choice.delta;\n            if (!delta) {\n                throw new Error('No delta returned');\n            }\n\n            if (delta.content) {\n                content = content ? content + delta.content : delta.content;\n\n                // Write also to the stream of the thread\n                if (!this._stream) {\n                    throw new Error('No stream available');\n                }\n                this._stream?.push(delta.content);\n            }\n\n            // Merge toolCalls\n            if (delta.toolCalls) {\n                for (const [index, toolCall] of delta.toolCalls.entries()) {\n                    const existingToolCall = toolCalls[index];\n\n                    if (existingToolCall) {\n                        existingToolCall.function.arguments +=\n                            toolCall.function.arguments;\n                    } else {\n                        toolCalls.push(toolCall);\n                    }\n                }\n            }\n\n            if (choice.finishReason === null) {\n                return;\n            }\n\n            const message: ChatResponseMessage = {\n                role: 'assistant',\n                content,\n                toolCalls,\n            };\n            this.doAddMessage(message);\n\n            switch (choice.finishReason) {\n                case 'stop':\n                    this._stream?.push(null);\n                    this.emit('completed');\n                    break;\n                case 'tool_calls': {\n                    const requiredAction = new RequiredAction(toolCalls);\n                    requiredAction.on(\n                        'submitting',\n                        (toolOutputs: ToolOutput[]) => {\n                            // Adds the tool outputs to the messages\n                            for (const toolOutput of toolOutputs) {\n                                const message: ChatRequestToolMessage = {\n                                    role: 'tool',\n                                    content: JSON.stringify(toolOutput.value),\n                                    toolCallId: toolOutput.callId,\n                                };\n                                this.doAddMessage(message);\n                            }\n\n                            this.doRun(assistant);\n                        },\n                    );\n                    this.emit('requires_action', requiredAction);\n                    break;\n                }\n                default:\n                    throw new Error(\n                        `Unknown finish reason ${choice.finishReason}`,\n                    );\n            }\n        });\n    }\n\n    /**\n     * Convert the mix of ChatRequestMessages and ChatResponseMessages to ChatRequestMessages only\n     * so they can be sent again to the LLM.\n     */\n    private getRequestMessages(): ChatRequestMessage[] {\n        return this.messages.map((m) => {\n            if (m.role === 'system' || m.role === 'user' || m.role === 'tool') {\n                // These are messages from the application (a.k.a request messages)\n                return m as ChatRequestMessage;\n            } else {\n                // These are messages from the assistant (a.k.a response messages)\n                const responseMessage = m as ChatResponseMessage;\n                return {\n                    role: 'assistant',\n                    content: responseMessage.content,\n                    toolCalls: responseMessage.toolCalls,\n                };\n            }\n        });\n    }\n\n    private doAddMessage(\n        message: ChatRequestMessage | ChatResponseMessage,\n    ): void {\n        this.messages.push(message);\n        this.emit('message', message);\n\n        if (isChatRequestMessage(message)) {\n            this.emit('message:request', message);\n        } else {\n            this.emit('message:response', message);\n        }\n    }\n}\n\nexport class RequiredAction extends EventEmitter {\n    constructor(public readonly toolCalls: ChatCompletionsToolCall[]) {\n        super();\n    }\n\n    submitToolOutputs(toolOutputs: ToolOutput[]): void {\n        this.emit('submitting', toolOutputs);\n    }\n}\n\nexport interface ToolOutput {\n    callId: string;\n    value: unknown;\n}\n\nexport function isChatResponseMessage(\n    m: ChatRequestMessage | ChatResponseMessage,\n): m is ChatResponseMessage {\n    return 'toolCalls' in m;\n}\n\nexport function isChatRequestMessage(\n    m: ChatRequestMessage | ChatResponseMessage,\n): m is ChatRequestMessage {\n    return !isChatResponseMessage(m);\n}\n"],"names":[],"mappings":"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"}