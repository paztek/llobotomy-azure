{"version":3,"file":"index.js","sources":["../src/assistant/assistant.ts","../src/thread/thread.ts"],"sourcesContent":["import type { FunctionDefinition, OpenAIClient } from '@azure/openai';\nimport type { GetChatCompletionsOptions } from '@azure/openai/types/src/api/models';\nimport type { ChatMessage } from '@azure/openai/types/src/models/models';\nimport { Readable } from 'stream';\n\nexport interface AssistantCreateParams {\n    client: OpenAIClient;\n    instructions: string;\n    functions: FunctionDefinition[];\n    deployment: string;\n}\n\nexport class Assistant {\n    public readonly client: OpenAIClient;\n\n    private readonly instructions: string;\n    private readonly functions: FunctionDefinition[];\n    private readonly deployment: string;\n\n    constructor(params: AssistantCreateParams) {\n        this.client = params.client;\n        this.instructions = params.instructions;\n        this.functions = params.functions;\n        this.deployment = params.deployment;\n    }\n\n    listChatCompletions(messages: ChatMessage[]): Readable {\n        // Prepend the messages with our instructions as a \"system\" message\n        const systemMessage: ChatMessage = {\n            role: 'system',\n            content: this.instructions,\n        };\n        messages = [systemMessage, ...messages];\n\n        const options: GetChatCompletionsOptions = {\n            functions: this.functions,\n        };\n\n        const completions = this.client.listChatCompletions(\n            this.deployment,\n            messages,\n            options,\n        );\n\n        return Readable.from(completions, {\n            objectMode: true,\n        });\n    }\n}\n","import type { ChatCompletions, ChatMessage, FunctionCall } from '@azure/openai';\nimport EventEmitter from 'events';\nimport { Readable } from 'stream';\nimport { Assistant } from '../assistant';\n\nexport class Thread extends EventEmitter {\n    private _stream: Readable | null = null;\n\n    constructor(private readonly messages: ChatMessage[] = []) {\n        super();\n    }\n\n    get stream(): Readable | null {\n        if (!this._stream) {\n            return null;\n        }\n\n        return this._stream;\n    }\n\n    addMessage(message: ChatMessage): void {\n        this.messages.push(message);\n        this.emit('message', message);\n    }\n\n    run(assistant: Assistant): void {\n        this._stream = new Readable({\n            read: () => {},\n        });\n        this.doRun(assistant);\n    }\n\n    private doRun(assistant: Assistant): void {\n        this.emit('in_progress');\n\n        const stream = assistant.listChatCompletions(this.messages);\n\n        /**\n         * When the LLM responds with a function call, the first completion's first choice looks like this:\n         * {\n         *   index: 0,\n         *   finishReason: null,\n         *   delta: {\n         *     role: 'assistant',\n         *     functionCall: { name: 'get_customer_profile', arguments: undefined }\n         *   },\n         *   contentFilterResults: {}\n         * }\n         *\n         * When the LLM responds with a message, the first completion's first choice looks like this:\n         * {\n         *   index: 0,\n         *   finishReason: null,\n         *   delta: {\n         *     role: 'assistant',\n         *   },\n         *   contentFilterResults: {}\n         *\n         * We're only interested in the first completion and then we let the dedicated handler handle the rest of the stream\n         */\n        stream.once('data', (completion: ChatCompletions) => {\n            const choice = completion.choices[0];\n            if (!choice) {\n                throw new Error('No completions returned');\n            }\n\n            const delta = choice.delta;\n            if (!delta) {\n                throw new Error('No delta returned');\n            }\n\n            if (delta.functionCall) {\n                const name = delta.functionCall.name;\n                this.handleStreamAsFunctionCall(name, stream, assistant);\n            } else {\n                this.handleStreamAsChatMessage(stream);\n            }\n        });\n    }\n\n    /**\n     * Handles the stream as a function call after we determined from the beginning of the stream that it is a function call.\n     * The stream emits some completions.\n     * The first choice of these completions successively looks like this:\n     * {\n     *   index: 0,\n     *   finishReason: null,\n     *   delta: { functionCall: { name: undefined, arguments: '{\"' } }, <---- beginning of the arguments as a stringified JSON\n     *   contentFilterResults: {}\n     * }\n     * ... <---- more completions\n     * {\n     *   index: 0,\n     *   finishReason: null,\n     *   delta: { functionCall: { name: undefined, arguments: '\"}' } } <---- end of the arguments as a stringified JSON\n     * }\n     * { index: 0, finishReason: 'function_call', delta: {} } <---- end of the function call\n     */\n    private handleStreamAsFunctionCall(\n        name: string,\n        stream: Readable,\n        assistant: Assistant,\n    ): void {\n        let args = '';\n\n        stream.on('data', (completions: ChatCompletions) => {\n            const choice = completions.choices[0];\n            if (!choice) {\n                throw new Error('No completions returned');\n            }\n            const delta = choice.delta;\n            if (!delta) {\n                throw new Error('No delta returned');\n            }\n\n            if (delta.functionCall) {\n                const functionCall = delta.functionCall;\n                if (functionCall.arguments) {\n                    args += functionCall.arguments;\n                }\n            }\n\n            if (choice.finishReason === 'function_call') {\n                const functionCall: FunctionCall = {\n                    name,\n                    arguments: args,\n                };\n\n                // Adds the assistant's response to the messages\n                const message: ChatMessage = {\n                    role: 'assistant',\n                    content: null,\n                    functionCall,\n                };\n                this.addMessage(message);\n\n                const requiredAction = new RequiredAction({\n                    name,\n                    arguments: args,\n                });\n\n                requiredAction.on('submitting', (toolOutput: ToolOutput) => {\n                    // Adds the tool output to the messages\n                    const message: ChatMessage = {\n                        role: 'function',\n                        name: functionCall.name,\n                        content: JSON.stringify(toolOutput),\n                    };\n                    this.addMessage(message);\n\n                    this.doRun(assistant);\n                });\n\n                this.emit('requires_action', requiredAction);\n            }\n        });\n    }\n\n    /**\n     * Handles the stream as a chat message after we determined from the beginning of the stream that it is a chat message.\n     * The stream emits some completions.\n     * The first choice of these completions successively looks like this:\n     * {\n     *   index: 0,\n     *   finishReason: null,\n     *   delta: { content: \"Lorem\" }, <---- beginning of the response\n     *   contentFilterResults: {}\n     * }\n     * ... <---- more completions\n     * {\n     *   index: 0,\n     *   finishReason: null,\n     *   delta: { content: \" ipsum\" } <---- end of the response\n     * }\n     * { index: 0, finishReason: 'stop', delta: {} } <---- end of the message\n     */\n    private handleStreamAsChatMessage(stream: Readable): void {\n        let content = '';\n\n        stream.on('data', (completions: ChatCompletions) => {\n            const choice = completions.choices[0];\n            if (!choice) {\n                throw new Error('No completions returned');\n            }\n            const delta = choice.delta;\n            if (!delta) {\n                throw new Error('No delta returned');\n            }\n\n            if (delta.content) {\n                content += delta.content;\n\n                // Write also to the stream of the thread\n                if (!this._stream) {\n                    throw new Error('No stream available');\n                }\n                this._stream?.push(delta.content);\n            }\n\n            if (choice.finishReason === 'stop') {\n                // Adds the assistant's response to the messages\n                const message: ChatMessage = {\n                    role: 'assistant',\n                    content,\n                };\n                this.addMessage(message);\n\n                this.emit('completed');\n                this._stream?.push(null);\n            }\n        });\n    }\n}\n\nexport class RequiredAction extends EventEmitter {\n    toolCall: ToolCall;\n\n    constructor(functionCall: FunctionCall) {\n        super();\n\n        this.toolCall = {\n            name: functionCall.name,\n            arguments: JSON.parse(functionCall.arguments),\n        };\n    }\n\n    submitToolOutput(toolOutput: ToolOutput): void {\n        this.emit('submitting', toolOutput);\n    }\n}\n\nexport interface ToolCall {\n    name: string;\n    arguments: Record<string, unknown>;\n}\n\nexport interface ToolOutput {\n    value: unknown;\n}\n"],"names":["Readable"],"mappings":"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"}